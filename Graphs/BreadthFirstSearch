/*package Module4;

import java.util.*;

public class BreadthFirstSearch {
    //Inner class to represent a graph node
    static class GraphNode {
        String name;
        List<GraphNode> neighbors;
        boolean visited;

        public GraphNode(String name) {
            this.name = name;
            this.neighbors = new ArrayList<>();
            this.visited = false;
        }

        @Override
        public String toString() {
            return name; // Return the name of the node
        }

        //Method to print the adjacency list of the node
        public void printAdjacencyList() {
            System.out.print("Neighbors of node " + name + ": ");
            for (GraphNode neighbor : neighbors) {
                System.out.print(neighbor.name + " ");
            }
            System.out.println();
        }
    }

    //Breadth First Search algorithm implementation
    public static boolean breadthFirstSearch(GraphNode startVertex, GraphNode endVertex, Map<GraphNode, GraphNode> path) {
        //Initialize a queue for BFS
        Queue<GraphNode> queue = new LinkedList<>();

        //Set found to false
        boolean found = false;

        //Clear all marks
        clearMarks(startVertex);

        //Mark the startVertex
        startVertex.visited = true;

        //Enqueue the startVertex into the queue
        queue.add(startVertex);
        System.out.println("Starting BFS from " + startVertex.name);

        //Perform BFS
        while (!queue.isEmpty() && !found) {
            //Dequeue a vertex
            GraphNode currentVertex = queue.poll();
            System.out.println("Visiting node: " + currentVertex.name);

            //If current vertex equals endVertex, set found to true
            if (currentVertex == endVertex) {
                found = true;
                System.out.println("End vertex " + endVertex.name + " found!");
            } else {
                //Iterate through adjacent vertices
                for (GraphNode neighbor : currentVertex.neighbors) {
                    //If adjacent vertex is not marked
                    if (!neighbor.visited) {
                        //Mark the adjacent vertex, enqueue it into the queue, and track the path
                        neighbor.visited = true;
                        path.put(neighbor, currentVertex);
                        queue.add(neighbor);
                        System.out.println("Adding neighbor " + neighbor.name + " to the queue.");
                    }
                    else {
                        System.out.println("Neighbor " + neighbor.name + " is already visited.");
                    }
                }
            }
        }
        return found;
    }

    //Helper method to clear marks
    private static void clearMarks(GraphNode startVertex) {
        Queue<GraphNode> queue = new LinkedList<>();
        Set<GraphNode> visited = new HashSet<>();
        queue.add(startVertex);
        visited.add(startVertex);

        while (!queue.isEmpty()) {
            GraphNode current = queue.poll();
            current.visited = false;
            for (GraphNode neighbor : current.neighbors) {
                if (!visited.contains(neighbor)) {
                    queue.add(neighbor);
                    visited.add(neighbor);
                }
            }
        }
    }

    //Method to retrieve path from start to end
    public static List<GraphNode> retrievePath(Map<GraphNode, GraphNode> path, GraphNode start, GraphNode end) {
        List<GraphNode> result = new ArrayList<>();
        GraphNode current = end;
        while (current != null && !current.equals(start)) {
            result.add(0, current);
            current = path.get(current);
        }
        if (current != null && current.equals(start))
            result.add(0, start);
        return result;
    }
}*/



package Assignment4;

import java.util.*;

public class BreadthFirstSearch {
    // Breadth First Search algorithm implementation for flight routes
    public static boolean breadthFirstSearch(String startAirport, String endAirport, Map<String, List<FlightRoute>> routes) {
        // Initialize a queue for BFS
        Queue<String> queue = new LinkedList<>();

        // Initialize a set to keep track of visited airports
        Set<String> visited = new HashSet<>();
        
        Map<String, String> path = new HashMap<>();


        // Set found to false
        boolean found = false;

        // Clear all marks
        visited.clear();

        // Mark the startAirport
        visited.add(startAirport);
        path.put(startAirport, null);

        // Enqueue the startAirport into the queue
        queue.add(startAirport);
        System.out.println("Starting BFS from " + startAirport+ " to " + endAirport);

        // Perform BFS
        double totalCost = 0;
        while (!queue.isEmpty() && !found) {
            // Dequeue an airport
            String currentAirport = queue.poll();
            System.out.println("Visiting airport: " + currentAirport);

            // If current airport equals endAirport, set found to true
            if (currentAirport.equals(endAirport)) {
                found = true;
                System.out.println("End airport " + endAirport + " found!");
            } else {
                // Iterate through adjacent airports (destinations)
                List<FlightRoute> flightRoutes = routes.getOrDefault(currentAirport, Collections.emptyList());
                for (FlightRoute route : flightRoutes) {
                    String nextAirport = route.getDestination();
                    // If adjacent airport is not visited
                    if (!visited.contains(nextAirport)) {
                        // Mark the adjacent airport, enqueue it into the queue
                        visited.add(nextAirport);
                        queue.add(nextAirport);
                        
                        System.out.println("Adding airport " + nextAirport + " to the queue.");
                        totalCost += route.getCost();
                    } else {
                        System.out.println("Airport " + nextAirport + " is already visited.");
                    }
                }
            }
        }
        
        if (!found) {
            //System.out.println("No path exists from " + startAirport + " to " + endAirport);
            return false;
        }
        
        // Display total cost of the trip
        System.out.println("Total Cost of Trip: $" + totalCost);
        return true;
    }
   
    
 // Helper method to retrieve the destination airport of a flight route
    private static String getDestinationAirport(FlightRoute route) {
        return route.getDestination();
    }

    // Helper method to mark an airport as visited
    private static void markAirportAsVisited(String airport, Set<String> visited) {
        visited.add(airport);
    }

    // Helper method to check if an airport is marked as visited
    private static boolean isAirportVisited(String airport, Set<String> visited) {
        return visited.contains(airport);
    }
    
}


